# GCS-FFmpeg間のストリーム処理設計

## 目的

Cloud Run上での音声抽出処理時にメモリクラッシュ（OOM）が発生するリスクを解消するため、
GCSからFFmpegへの動画受け渡し、および音声のGCSへのアップロードをストリーム処理化し、メモリ使用量を大幅に削減する。

## 背景・現状の問題

### 現在のフロー（Phase 1完了後）

```
GCS（キャッシュ済み動画）
        ↓
tempStorageGateway.download(gcsUri) ← 動画全体をBufferに読み込み
        ↓
videoProcessingGateway.extractAudio(videoBuffer) ← BufferからBufferへ変換
        ↓
音声Buffer（メモリに保持）
        ↓
Speech-to-Text Batch API（GCSにアップロード後、処理）
```

### 問題点

1. `ExtractAudioUseCase` で `tempStorageGateway.download()` を呼び出し、動画全体をメモリに展開
2. `FFmpegClient.extractAudio()` も入力を一時ファイルに書き込むが、まず全Bufferを受け取る必要がある
3. 音声も一旦Bufferとして保持してから `TranscribeAudioUseCase` へ渡す
4. 大容量動画（1GB超）の場合、動画Buffer + 音声Bufferで数GBのメモリを消費

### コード箇所

**ExtractAudioUseCase（68-74行目）:**
```typescript
// 動画全体をBufferとしてダウンロード
const videoBuffer = await this.tempStorageGateway.download(video.gcsUri);

// BufferをFFmpegに渡す
const audioBuffer = await this.videoProcessingGateway.extractAudio(videoBuffer, format);
```

**FFmpegClient.extractAudio（85-114行目）:**
```typescript
async extractAudio(videoBuffer: Buffer, format: 'wav' | 'flac'): Promise<Buffer> {
  // Bufferを一時ファイルに書き込み
  await fs.promises.writeFile(inputPath, videoBuffer);

  // FFmpegで処理

  // 結果をBufferとして返却
  const result = await fs.promises.readFile(outputPath);
  return result;
}
```

## 設計方針

### 本設計のスコープ

GCS → FFmpeg → GCS の処理をストリーム化し、音声抽出時のメモリ使用量を削減する。

1. GCSからのダウンロードを一時ファイルへ直接ストリーム保存（Buffer経由なし）
2. FFmpegの出力を直接GCSへストリームアップロード
3. Speech-to-Text Batch APIは既にGCS URIを受け取れるため、音声のGCS URIを渡す

### 処理フローの変更

**Before:**
```
GCS → Buffer → 一時ファイル → FFmpeg → 一時ファイル → Buffer → Speech-to-Text
```

**After:**
```
GCS → Stream → 一時ファイル → FFmpeg → 一時ファイル → Stream → GCS → Speech-to-Text（GCS URI）
```

## Gateway インターフェース変更

### VideoProcessingGateway

```typescript
export interface VideoProcessingGateway {
  // 既存（Buffer版）
  extractAudio(videoBuffer: Buffer, format: 'wav' | 'flac'): Promise<Buffer>;
  extractClip(videoBuffer: Buffer, startTimeSeconds: number, endTimeSeconds: number): Promise<Buffer>;
  getVideoDuration(videoBuffer: Buffer): Promise<number>;

  // 新規追加（Stream版）
  extractAudioFromFile(inputPath: string, outputPath: string, format: 'wav' | 'flac'): Promise<void>;
}
```

### TempStorageGateway（変更なし）

既存の `downloadAsStream()` を活用する。

```typescript
export interface TempStorageGateway {
  downloadAsStream(gcsUri: string): Readable;
  uploadFromStream(params: TempStorageStreamUploadParams, source: Readable): Promise<TempStorageUploadResult>;
}
```

## Infrastructure実装

### FFmpegClient

```typescript
/**
 * Extract audio from a video file to a file
 * Memory efficient: no buffer loading required
 */
async extractAudioFromFile(
  inputPath: string,
  outputPath: string,
  format: 'wav' | 'flac'
): Promise<void> {
  await new Promise<void>((resolve, reject) => {
    const command = ffmpeg(inputPath)
      .noVideo()
      .audioFrequency(16000)
      .audioChannels(1);

    if (format === 'wav') {
      command.audioCodec('pcm_s16le');
    } else {
      command.audioCodec('flac');
    }

    command
      .output(outputPath)
      .on('end', () => resolve())
      .on('error', (err: Error) => reject(err))
      .run();
  });
}
```

## UseCase 変更

### ExtractAudioUseCase

現在のBuffer版を維持しつつ、新しいストリーム版を追加。

```typescript
export interface ExtractAudioStreamResult {
  videoId: string;
  audioGcsUri: string;
  format: 'wav' | 'flac';
}

/**
 * Stream版: 音声をGCSに直接アップロード
 * Memory efficient: 大容量動画でもOOMしない
 */
async executeWithStream(videoId: string, format: 'wav' | 'flac' = 'flac'): Promise<ExtractAudioStreamResult> {
  // 1. GCSからストリームで一時ファイルにダウンロード
  const tempDir = await fs.promises.mkdtemp(path.join(os.tmpdir(), 'extract-audio-'));
  const inputPath = path.join(tempDir, 'input.mp4');
  const outputPath = path.join(tempDir, `output.${format}`);

  try {
    // Stream → File（メモリ使用なし）
    const downloadStream = this.tempStorageGateway.downloadAsStream(video.gcsUri);
    await pipeline(downloadStream, fs.createWriteStream(inputPath));

    // 2. FFmpegでファイル → ファイル変換
    await this.videoProcessingGateway.extractAudioFromFile(inputPath, outputPath, format);

    // 3. 出力ファイルをGCSへストリームアップロード
    const uploadStream = fs.createReadStream(outputPath);
    const { gcsUri } = await this.tempStorageGateway.uploadFromStream(
      { videoId, contentType: format === 'wav' ? 'audio/wav' : 'audio/flac', path: `audio.${format}` },
      uploadStream
    );

    return { videoId, audioGcsUri: gcsUri, format };
  } finally {
    await this.cleanup(tempDir);
  }
}
```

### TranscribeAudioUseCase

GCS URIを受け取れるようにインターフェースを拡張。

```typescript
// 既存（Buffer版）
async execute(videoId: string, audioBuffer: Buffer, format: 'wav' | 'flac'): Promise<TranscribeResult>;

// 新規追加（GCS URI版）
async executeWithGcsUri(videoId: string, audioGcsUri: string): Promise<TranscribeResult>;
```

Speech-to-Text Batch APIは既にGCS URIを入力として受け取れるため、音声のアップロード処理をスキップできる。

### CreateTranscriptUseCase

ストリーム版UseCaseを呼び出すように変更。

```typescript
async execute(videoId: string): Promise<CreateTranscriptResult> {
  // Phase 1: Download video to GCS (stream)
  await this.cacheVideoUseCase.execute(videoId);

  // Phase 2: Extract audio to GCS (stream) ← 変更点
  const { audioGcsUri } = await this.extractAudioUseCase.executeWithStream(videoId, 'flac');

  // Phase 3: Transcribe from GCS URI ← 変更点
  const { transcriptionId } = await this.transcribeAudioUseCase.executeWithGcsUri(videoId, audioGcsUri);

  // Phase 4: Refine (optional)
  await this.refineTranscriptUseCase.execute(videoId);

  return { videoId, transcriptionId };
}
```

## TempStorageGateway インターフェース拡張

音声ファイル用のパスを指定できるようにパラメータを拡張。

```typescript
export interface TempStorageStreamUploadParams {
  videoId: string;
  contentType?: string;
  path?: string;  // 新規追加: カスタムパス（例: 'audio.flac'）
}
```

GCSパス構成:
```
gs://bucket/videos/{videoId}/original.mp4  # 動画
gs://bucket/videos/{videoId}/audio.flac    # 音声（新規）
```

## エラーハンドリング

### 一時ファイルのクリーンアップ

処理途中でエラーが発生した場合も、必ず一時ディレクトリを削除する。

```typescript
try {
  // 処理
} finally {
  await this.cleanup(tempDir);
}
```

### GCSアップロード失敗

アップロード途中でエラーが発生した場合:
- 不完全なファイルがGCSに残る可能性
- catch時に `file.delete()` でクリーンアップを試みる

### ストリームエラー

`pipeline()` がエラーをthrowするため、try-catchで捕捉して適切にハンドリング。

## 実装項目

### 1. Gateway インターフェース変更

| ファイル | 変更内容 |
|---------|---------|
| `domain/gateways/video-processing.gateway.ts` | `extractAudioFromFile` メソッド追加 |
| `domain/gateways/temp-storage.gateway.ts` | `TempStorageStreamUploadParams.path` 追加 |

### 2. Infrastructure実装

| ファイル | 変更内容 |
|---------|---------|
| `infrastructure/clients/ffmpeg.client.ts` | `extractAudioFromFile` 実装 |
| `infrastructure/clients/gcs.client.ts` | パスパラメータ対応 |
| `infrastructure/clients/local-temp-storage.client.ts` | パスパラメータ対応 |

### 3. UseCase修正

| ファイル | 変更内容 |
|---------|---------|
| `application/usecases/extract-audio.usecase.ts` | `executeWithStream` 追加 |
| `application/usecases/transcribe-audio.usecase.ts` | `executeWithGcsUri` 追加 |
| `application/usecases/create-transcript.usecase.ts` | ストリーム版呼び出しに変更 |

### 4. Integration Test（必須）

| ファイル | テスト内容 |
|---------|---------|
| `test/integration/infrastructure/clients/ffmpeg.client.test.ts` | `extractAudioFromFile` のテスト追加 |
| `test/integration/application/usecases/extract-audio.usecase.test.ts` | **新規作成**: ストリーム版のE2Eテスト |

## テスト方針

### FFmpegClient Integration Test（追加）

```typescript
describe('extractAudioFromFile', () => {
  it('should extract WAV audio from file to file', async () => {
    const tempDir = await fs.promises.mkdtemp(path.join(os.tmpdir(), 'ffmpeg-test-'));
    const inputPath = path.join(tempDir, 'input.mp4');
    const outputPath = path.join(tempDir, 'output.wav');

    // テスト動画をコピー
    await fs.promises.copyFile(SAMPLE_VIDEO_PATH, inputPath);

    // 実行
    await client.extractAudioFromFile(inputPath, outputPath, 'wav');

    // 検証
    const audioBuffer = await fs.promises.readFile(outputPath);
    expect(audioBuffer.slice(0, 4).toString('ascii')).toBe('RIFF');

    // クリーンアップ
    await fs.promises.rm(tempDir, { recursive: true });
  });

  it('should extract FLAC audio from file to file', async () => {
    // ... similar test for FLAC
  });

  it('should handle large file without memory spike', async () => {
    // メモリ使用量をモニタリングしながら処理
    // 処理中のメモリ増加が一定以下であることを検証
  });
});
```

### ExtractAudioUseCase Integration Test（新規作成）

```typescript
// test/integration/application/usecases/extract-audio.usecase.test.ts

describe.skipIf(!runIntegrationTests)('ExtractAudioUseCase Integration', () => {
  describe('executeWithStream', () => {
    it('should extract audio and upload to GCS', async () => {
      // Setup: ローカルストレージに動画を配置
      const videoId = 'test-video-id';

      // Execute
      const result = await useCase.executeWithStream(videoId, 'flac');

      // Verify
      expect(result.audioGcsUri).toMatch(/audio\.flac$/);

      // GCS/ローカルにファイルが存在することを確認
      const exists = await tempStorageGateway.exists(result.audioGcsUri);
      expect(exists).toBe(true);
    });

    it('should not spike memory for large video', async () => {
      // 大容量動画での処理
      // メモリ使用量が一定以下であることを検証
    });

    it('should cleanup temp files on error', async () => {
      // エラー発生時に一時ファイルが残らないことを検証
    });
  });
});
```

### CreateTranscriptUseCase Integration Test（修正）

既存のテストを修正し、ストリーム版の動作を検証。

```typescript
describe('execute with stream', () => {
  it('should process video using stream throughout', async () => {
    // 一連のフローがストリーム処理で動作することを検証
  });
});
```

## メモリ効率の期待値

### Before（現状）
- 1GB動画の場合: 動画Buffer（1GB） + 音声Buffer（100MB程度） = 約1.1GB使用

### After（本設計適用後）
- 1GB動画の場合: ストリーム処理のため、数十MB程度のバッファのみ使用

## 環境変数

変更なし。既存の環境変数をそのまま使用。

## ファイル一覧

| ファイル | 変更種別 | 内容 |
|---------|---------|------|
| `domain/gateways/video-processing.gateway.ts` | 修正 | `extractAudioFromFile` 追加 |
| `domain/gateways/temp-storage.gateway.ts` | 修正 | `path` パラメータ追加 |
| `infrastructure/clients/ffmpeg.client.ts` | 修正 | ストリーム版メソッド実装 |
| `infrastructure/clients/gcs.client.ts` | 修正 | パスパラメータ対応 |
| `infrastructure/clients/local-temp-storage.client.ts` | 修正 | パスパラメータ対応 |
| `application/usecases/extract-audio.usecase.ts` | 修正 | `executeWithStream` 追加 |
| `application/usecases/transcribe-audio.usecase.ts` | 修正 | `executeWithGcsUri` 追加 |
| `application/usecases/create-transcript.usecase.ts` | 修正 | ストリーム版呼び出し |
| `test/integration/infrastructure/clients/ffmpeg.client.test.ts` | 修正 | ストリーム版テスト追加 |
| `test/integration/application/usecases/extract-audio.usecase.test.ts` | **新規** | ストリーム版統合テスト |
