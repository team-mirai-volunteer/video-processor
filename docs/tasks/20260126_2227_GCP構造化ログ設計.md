# GCP構造化ログ設計

## 目的

開発者がCloud Run上でアプリケーションエラーを調査する際、ログレベルが正しく分類されておらず、ERROR/WARNINGログをフィルタリングできない状態を解消するため。

## 背景

現在の問題:
- `console.error` で出力したエラーがCloud LoggingでINFOレベルとして表示される
- ログ検索・フィルタリングが機能せず、障害調査に時間がかかる
- 各UseCaseが独自の`log()`メソッドを実装しており、フォーマットが不統一

## 設計方針

### DDDレイヤー別のログ責務

| レイヤー | ログ責務 | ログレベル |
|---------|---------|-----------|
| **presentation** | HTTPリクエスト/レスポンス、グローバルエラー | INFO, ERROR |
| **application** | UseCase実行フロー、ビジネスエラー | DEBUG, INFO, WARNING, ERROR |
| **domain** | ログ出力しない（純粋なビジネスロジック） | - |
| **infrastructure** | 外部サービス呼び出し、接続エラー | DEBUG, WARNING, ERROR |

Domain層はログを出力せず、Result型でエラーを表現する既存方針を維持する。

### GCP構造化ログフォーマット

Cloud Loggingが認識するJSON形式でログを出力する。

```typescript
interface StructuredLog {
  // 必須: Cloud Loggingが認識するseverity
  severity: 'DEBUG' | 'INFO' | 'NOTICE' | 'WARNING' | 'ERROR' | 'CRITICAL';

  // 必須: ログメッセージ（Error Reportingはこのフィールドを解析）
  message: string;

  // 推奨: イベント発生時刻（省略時はCloud Loggingが付与）
  timestamp?: string;

  // 推奨: ログ出力元の識別
  component?: string;  // e.g., "CreateTranscriptUseCase", "GoogleDriveClient"

  // オプション: 構造化された追加データ
  context?: Record<string, unknown>;

  // オプション: エラー時のスタックトレース（Error Reporting用）
  stack_trace?: string;

  // オプション: リクエストに紐づくHTTP情報
  httpRequest?: {
    requestMethod: string;
    requestUrl: string;
    status: number;
    userAgent?: string;
    latency?: string;
  };
}
```

参照: [Google Cloud Logging - Structured Logging](https://cloud.google.com/logging/docs/structured-logging)

### LogSeverityマッピング

GCPのLogSeverity仕様に基づき、アプリケーションで使用するレベルを定義する。

| Severity | 用途 |
|----------|------|
| DEBUG | 開発時のデバッグ情報、詳細なトレース |
| INFO | 正常な処理フロー、状態変更 |
| WARNING | 処理は継続するが注意が必要な事象 |
| ERROR | 処理失敗、例外発生 |
| CRITICAL | システム全体に影響する重大エラー |

参照: [LogSeverity enum](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logseverity)

## アーキテクチャ

### ファイル配置

```
apps/backend/src/
├── infrastructure/
│   └── logging/
│       └── logger.ts           # Loggerインターフェースとシングルトン実装
```

Loggerはinfrastructure層に配置し、シングルトンとしてエクスポートする。

DIではなくシングルトンを採用する理由:
- ログ出力のためだけに全クラスにLoggerをドリリングするのは過剰
- ログ出力のモック化が必要なケースは限定的
- 実装がシンプルになる

### Loggerインターフェースとシングルトン

```typescript
// infrastructure/logging/logger.ts

type LogLevel = 'DEBUG' | 'INFO' | 'WARNING' | 'ERROR' | 'CRITICAL';

interface LogContext {
  [key: string]: unknown;
}

interface Logger {
  debug(message: string, context?: LogContext): void;
  info(message: string, context?: LogContext): void;
  warn(message: string, context?: LogContext): void;
  error(message: string, error?: Error, context?: LogContext): void;
  critical(message: string, error?: Error, context?: LogContext): void;
}

class GcpLogger implements Logger {
  private readonly isProduction = process.env.NODE_ENV === 'production';

  private log(severity: LogLevel, message: string, context?: LogContext, error?: Error): void {
    // DEBUGは本番環境では出力しない
    if (severity === 'DEBUG' && this.isProduction) {
      return;
    }

    const entry: StructuredLog = {
      severity,
      message,
      timestamp: new Date().toISOString(),
    };

    if (context && Object.keys(context).length > 0) {
      entry.context = context;
    }

    // Error Reporting 統合: スタックトレースを message に含める
    if (error?.stack) {
      entry.message = `${message}\n${error.stack}`;
      entry.stack_trace = error.stack;
    }

    // stdout に JSON 出力 → Cloud Logging Agent が収集
    console.log(JSON.stringify(entry));
  }

  debug(message: string, context?: LogContext): void {
    this.log('DEBUG', message, context);
  }

  info(message: string, context?: LogContext): void {
    this.log('INFO', message, context);
  }

  warn(message: string, context?: LogContext): void {
    this.log('WARNING', message, context);
  }

  error(message: string, error?: Error, context?: LogContext): void {
    this.log('ERROR', message, context, error);
  }

  critical(message: string, error?: Error, context?: LogContext): void {
    this.log('CRITICAL', message, context, error);
  }
}

// シングルトンとしてエクスポート
export const logger = new GcpLogger();

// コンポーネント名を固定したロガーを作成するヘルパー
export function createLogger(component: string): Logger {
  return {
    debug: (msg, ctx) => logger.debug(`[${component}] ${msg}`, ctx),
    info: (msg, ctx) => logger.info(`[${component}] ${msg}`, ctx),
    warn: (msg, ctx) => logger.warn(`[${component}] ${msg}`, ctx),
    error: (msg, err, ctx) => logger.error(`[${component}] ${msg}`, err, ctx),
    critical: (msg, err, ctx) => logger.critical(`[${component}] ${msg}`, err, ctx),
  };
}
```

### なぜ console.log を使うか

Cloud Runでは、stdout/stderrに出力されたJSONログをCloud Logging Agentが自動収集する。
`@google-cloud/logging` ライブラリを使う方法もあるが、以下の理由でconsole.log + JSON形式を採用する:

1. **シンプルさ**: 追加ライブラリ不要
2. **Cloud Run推奨**: `redirectToStdout: true` がサーバーレス環境での推奨設定
3. **ログ欠損防止**: プロセス終了時にもログが確実に出力される

## 適用箇所

### 1. presentation層: エラーハンドラ

```typescript
// presentation/middleware/error-handler.ts
import { logger } from '../../infrastructure/logging/logger.js';

export function errorHandler(
  err: Error,
  _req: Request,
  res: Response,
  _next: NextFunction
): void {
  // ApplicationError は WARNING（ユーザー起因のエラー）
  if (err instanceof ApplicationError) {
    logger.warn(`[ErrorHandler] ${err.message}`, {
      errorName: err.name,
      statusCode: err.statusCode
    });
    res.status(err.statusCode).json({ error: err.message });
    return;
  }

  // 予期しないエラーは ERROR
  logger.error('[ErrorHandler] Unexpected error', err);
  res.status(500).json({
    error: process.env.NODE_ENV === 'production' ? 'Internal Server Error' : err.message
  });
}
```

### 2. presentation層: リクエストログ

```typescript
// presentation/middleware/request-logger.ts
import { logger } from '../../infrastructure/logging/logger.js';

export function requestLogger(req: Request, res: Response, next: NextFunction): void {
  const start = Date.now();

  res.on('finish', () => {
    const latency = Date.now() - start;
    const logData = {
      httpRequest: {
        requestMethod: req.method,
        requestUrl: req.originalUrl,
        status: res.statusCode,
        userAgent: req.get('user-agent'),
        latency: `${latency}ms`,
      },
    };

    // 5xx は ERROR、4xx は WARNING、それ以外は INFO
    if (res.statusCode >= 500) {
      logger.error(`[RequestLogger] ${req.method} ${req.path}`, undefined, logData);
    } else if (res.statusCode >= 400) {
      logger.warn(`[RequestLogger] ${req.method} ${req.path}`, logData);
    } else {
      logger.info(`[RequestLogger] ${req.method} ${req.path}`, logData);
    }
  });

  next();
}
```

### 3. application層: UseCase

`createLogger` ヘルパーでコンポーネント名を固定したロガーを使用する。

```typescript
// application/usecases/create-transcript.usecase.ts
import { createLogger } from '../../infrastructure/logging/logger.js';

const log = createLogger('CreateTranscriptUseCase');

export class CreateTranscriptUseCase {
  // constructor から logger を削除（DIドリリング不要）

  async execute(videoId: string): Promise<CreateTranscriptResult> {
    log.info('Starting execution', { videoId });

    try {
      // ... processing
      log.info('Video cached', { gcsUri: cacheResult.gcsUri });
    } catch (error) {
      log.error('Processing failed', error as Error, { videoId });
      throw error;
    }
  }
}
```

### 4. infrastructure層: 外部クライアント

```typescript
// infrastructure/clients/google-drive.client.ts
import { createLogger } from '../logging/logger.js';

const log = createLogger('GoogleDriveClient');

export class GoogleDriveClient {
  // constructor から logger を削除

  async downloadFileAsStream(fileId: string): Promise<Readable> {
    log.debug('Starting download', { fileId });

    try {
      // ... download logic
    } catch (error) {
      log.error('Download failed', error as Error, { fileId });
      throw error;
    }
  }
}
```

### 5. 非同期エラー（fire-and-forget）

現在問題となっている箇所:

```typescript
// 現在のコード（問題）
createTranscriptUseCase.execute(videoId ?? '').catch((error) => {
  console.error('[CreateTranscriptUseCase] Error:', error);  // INFOになる
});

// 修正後
import { logger } from '../../infrastructure/logging/logger.js';

createTranscriptUseCase.execute(videoId ?? '').catch((error) => {
  logger.error('[VideosRoute] Background transcription failed', error as Error, { videoId });
});
```

## Error Reporting 統合

Cloud Error Reportingと連携するため、ERROR以上のログでは:

1. `message` フィールドにスタックトレースを含める
2. `stack_trace` フィールドにもスタックトレースを設定

これにより、Error Reportingダッシュボードでエラーが自動的にグルーピングされる。

## 環境別の動作

| 環境 | DEBUG出力 | ログ出力先 |
|------|----------|-----------|
| development | 出力する | stdout (JSON) |
| production | 出力しない | stdout (JSON) |

DEBUGレベルの出力制御は `GcpLogger` クラス内で `NODE_ENV` を参照して行う（実装クラス参照）。

## 移行手順

1. `infrastructure/logging/logger.ts` にLogger実装を追加
2. 既存の `console.log/error` 呼び出しを `logger` または `createLogger` に置換
3. 各UseCaseの `private log()` メソッドを削除

## 参考資料

- [Google Cloud Logging - Structured Logging](https://cloud.google.com/logging/docs/structured-logging)
- [LogSeverity enum](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logseverity)
- [Setting Up Cloud Logging for Node.js](https://cloud.google.com/logging/docs/setup/nodejs)
