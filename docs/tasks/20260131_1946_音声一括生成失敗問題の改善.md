# 音声一括生成失敗問題の改善

## 目的

ユーザーがフロントエンドから音声の一括生成（生成ボタン経由）を実行した際に失敗するが、個別生成なら成功する問題を解消するため。

Fish Audio TTS APIには同時並行制限があり、複数リクエストを並列実行するとレート制限エラーが発生する可能性がある。個別生成では1リクエストのみ実行されるため成功するが、一括生成では複数シーンの音声生成が実行されるため、何らかの問題で失敗していると考えられる。

## 現状分析

### 既存実装の確認

#### バックエンド (synthesize-voice.usecase.ts)

`SynthesizeVoiceUseCase.execute()` メソッドでは、既に **直列処理** されている:

```typescript
// apps/backend/src/contexts/shorts-gen/application/usecases/synthesize-voice.usecase.ts:174-182
for (const scene of scenes) {
  const result = await this.processScene(scene, input.voiceModelId);
  // ...
}
```

各シーンは `for...of` ループで順番に処理され、並列実行はされていない。

#### フロントエンド (project-detail-client.tsx)

一括生成は以下のように実装されている:

```typescript
// apps/webapp/src/app/shorts-gen/[projectId]/project-detail-client.tsx:269-305
const handleAllVoicesGenerate = useCallback(async (): Promise<GenerateAllAssetsResponse> => {
  if (!script) throw new Error('Script not found');
  const response = await fetch(`/api/shorts-gen/scripts/${script.id}/voice`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
  });
  // ...
}, [script]);
```

フロントエンドは `/api/shorts-gen/scripts/${script.id}/voice` エンドポイント（バックエンドの `voice.routes.ts:85-122`）を呼び出し、バックエンド側で一括処理している。

#### Fish Audio TTS Client (fish-audio-tts.client.ts)

TTS API呼び出しは `synthesize()` メソッドで実装されている:

```typescript
// apps/backend/src/contexts/shorts-gen/infrastructure/clients/fish-audio-tts.client.ts:116-164
async synthesize(params: TtsSynthesizeParams): Promise<Result<TtsSynthesizeResult, TtsGatewayError>> {
  try {
    const response = await fetch(`${this.apiUrl}/v1/tts`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${this.apiKey}`,
      },
      body: JSON.stringify(requestBody),
    });

    if (!response.ok) {
      return this.handleErrorResponse(response, voiceModelId);
    }
    // ...
  } catch (error) {
    // レート制限エラーを検出
    if (error.message.includes('rate limit') || error.message.includes('429')) {
      return err({
        type: 'RATE_LIMIT_EXCEEDED',
        retryAfterMs: 60000,
      });
    }
    // ...
  }
}
```

レート制限エラーは検出されているが、**リトライ処理は実装されていない**。

### 問題の特定

現在の実装は既に直列処理になっているため、「並列ではなく直列にして」というユーザーの要求は既に満たされている。

しかし、以下の問題が考えられる:

1. **レート制限エラー時のリトライ処理がない**: Fish Audio APIがレート制限エラーを返した場合、即座に失敗する
2. **エラー発生時の継続処理**: 一部のシーンで失敗した場合でも、他のシーンの処理は継続される（現在の実装では正しく動作している）
3. **タイムアウト設定**: 長時間かかる一括生成でタイムアウトする可能性

調査の結果、**問題は既に直列処理になっているため、並列/直列の問題ではない**ことが判明。

実際の問題は以下の可能性が高い:

- **レート制限エラー時のリトライ処理がないこと**
- **Fish Audio APIが短時間に複数リクエストを受けると一時的にブロックする可能性**

## 設計方針

### 1. レート制限対応の改善

Fish Audio TTS Clientに以下の機能を追加:

- **指数バックオフによるリトライ処理**: レート制限エラー (429) 発生時、指数的に増加する待機時間でリトライ
- **リトライ設定のカスタマイズ**: 最大リトライ回数と初期待機時間を設定可能に

### 2. リクエスト間の待機時間追加

直列処理は既に実装されているが、Fish Audio APIの負荷を軽減するため、各リクエスト間に短い待機時間を挿入:

- **デフォルト待機時間**: 500ms～1秒程度
- **設定可能な待機時間**: 環境変数で調整可能に

### 3. エラーハンドリングの改善

現在の実装では、一部のシーンで失敗しても他のシーンの処理は継続される（`errors` 配列に追加される）。この挙動は適切だが、以下を改善:

- **リトライ可能なエラーと不可能なエラーの区別**: レート制限エラーはリトライ、無効なテキストエラーはスキップ
- **詳細なエラーログ**: どのシーンでどのようなエラーが発生したかを明確にログ出力

## 実装計画

### 1. Fish Audio TTS Clientの改善

**ファイル**: `apps/backend/src/contexts/shorts-gen/infrastructure/clients/fish-audio-tts.client.ts`

#### 変更内容

1. **リトライ設定の追加**:
   ```typescript
   export interface FishAudioTtsClientConfig {
     // ...既存のプロパティ
     maxRetries?: number;          // 最大リトライ回数（デフォルト: 3）
     initialRetryDelayMs?: number; // 初期リトライ待機時間（デフォルト: 1000）
   }
   ```

2. **指数バックオフリトライ処理の実装**:
   - `synthesize()` メソッド内でリトライループを実装
   - レート制限エラー (429) またはネットワークエラー発生時にリトライ
   - 待機時間は指数的に増加: `initialRetryDelayMs * (2 ** retryCount)`
   - `retryAfterMs` が返された場合はそれを優先

3. **環境変数からの設定読み込み**:
   ```
   FISH_AUDIO_MAX_RETRIES=3
   FISH_AUDIO_INITIAL_RETRY_DELAY_MS=1000
   ```

### 2. SynthesizeVoiceUseCaseの改善

**ファイル**: `apps/backend/src/contexts/shorts-gen/application/usecases/synthesize-voice.usecase.ts`

#### 変更内容

1. **リクエスト間待機時間の追加**:
   ```typescript
   export interface SynthesizeVoiceUseCaseDeps {
     // ...既存のプロパティ
     delayBetweenRequestsMs?: number; // デフォルト: 500
   }
   ```

2. **processScene() 後の待機処理**:
   ```typescript
   for (const scene of scenes) {
     const result = await this.processScene(scene, input.voiceModelId);

     if ('error' in result) {
       errors.push(result.error);
     } else {
       results.push(result.result);
     }

     // 次のシーン処理前に待機（最後のシーン以外）
     if (scene !== scenes[scenes.length - 1] && this.delayBetweenRequestsMs > 0) {
       await new Promise(resolve => setTimeout(resolve, this.delayBetweenRequestsMs));
     }
   }
   ```

3. **環境変数からの設定読み込み** (voice.routes.ts):
   ```
   VOICE_SYNTHESIS_DELAY_MS=500
   ```

### 3. エラーログの改善

- `processScene()` でエラー発生時、より詳細なログ出力:
  - シーンID、シーン順序、エラータイプ、リトライ回数など

### 4. テストの追加

#### 統合テスト

**ファイル**: `apps/backend/test/contexts/shorts-gen/infrastructure/clients/fish-audio-tts.client.integration.test.ts`

- レート制限エラー発生時のリトライ動作テスト（モックサーバーで429を返す）
- 最大リトライ回数到達時の挙動テスト

#### ユニットテスト

**ファイル**: `apps/backend/test/contexts/shorts-gen/application/usecases/synthesize-voice.usecase.test.ts`

- リクエスト間待機時間のテスト
- 複数シーン処理時のエラーハンドリングテスト

## 実装の詳細

### リトライロジックの実装

```typescript
async synthesize(params: TtsSynthesizeParams): Promise<Result<TtsSynthesizeResult, TtsGatewayError>> {
  let lastError: TtsGatewayError | null = null;

  for (let attempt = 0; attempt <= this.maxRetries; attempt++) {
    if (attempt > 0) {
      // リトライ前の待機
      const delay = lastError?.type === 'RATE_LIMIT_EXCEEDED' && lastError.retryAfterMs
        ? lastError.retryAfterMs
        : this.initialRetryDelayMs * Math.pow(2, attempt - 1);

      log.info(`Retrying synthesis (attempt ${attempt}/${this.maxRetries}) after ${delay}ms`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }

    try {
      const response = await fetch(/* ... */);

      if (!response.ok) {
        const errorResult = await this.handleErrorResponse(response, voiceModelId);

        if (!errorResult.success) {
          lastError = errorResult.error;

          // リトライ可能なエラーかチェック
          if (this.isRetryableError(lastError) && attempt < this.maxRetries) {
            continue; // リトライ
          }

          return errorResult; // リトライ不可またはリトライ上限
        }
      }

      // 成功
      const audioBuffer = Buffer.from(await response.arrayBuffer());
      // ...
      return ok({ audioBuffer, durationMs, format, sampleRate });

    } catch (error) {
      // ネットワークエラーなど
      if (attempt < this.maxRetries) {
        lastError = { type: 'SYNTHESIS_FAILED', message: error.message };
        continue; // リトライ
      }
      throw error;
    }
  }

  // すべてのリトライが失敗
  return err(lastError || { type: 'SYNTHESIS_FAILED', message: 'Unknown error' });
}

private isRetryableError(error: TtsGatewayError): boolean {
  return error.type === 'RATE_LIMIT_EXCEEDED' ||
         (error.type === 'API_ERROR' && error.statusCode >= 500);
}
```

### 待機時間の実装

```typescript
// SynthesizeVoiceUseCase内
for (let i = 0; i < scenes.length; i++) {
  const scene = scenes[i];
  const result = await this.processScene(scene, input.voiceModelId);

  if ('error' in result) {
    errors.push(result.error);
  } else {
    results.push(result.result);
  }

  // 最後のシーン以外は待機
  if (i < scenes.length - 1 && this.delayBetweenRequestsMs > 0) {
    log.debug(`Waiting ${this.delayBetweenRequestsMs}ms before next scene`);
    await new Promise(resolve => setTimeout(resolve, this.delayBetweenRequestsMs));
  }
}
```

## 環境変数

以下の環境変数を `.env` または環境設定に追加:

```bash
# Fish Audio TTS リトライ設定
FISH_AUDIO_MAX_RETRIES=3
FISH_AUDIO_INITIAL_RETRY_DELAY_MS=1000

# 音声合成リクエスト間待機時間（ミリ秒）
VOICE_SYNTHESIS_DELAY_MS=500
```

## 影響範囲

### 変更ファイル

- `apps/backend/src/contexts/shorts-gen/infrastructure/clients/fish-audio-tts.client.ts`
- `apps/backend/src/contexts/shorts-gen/application/usecases/synthesize-voice.usecase.ts`
- `apps/backend/src/contexts/shorts-gen/presentation/routes/voice.routes.ts`

### テストファイル

- `apps/backend/test/contexts/shorts-gen/infrastructure/clients/fish-audio-tts.client.integration.test.ts`
- `apps/backend/test/contexts/shorts-gen/application/usecases/synthesize-voice.usecase.test.ts`

## 期待される効果

1. **レート制限エラーの自動リトライ**: 一時的なレート制限エラーが自動的にリトライされ、失敗率が低下
2. **API負荷の軽減**: リクエスト間の待機時間により、Fish Audio APIへの負荷が分散
3. **より詳細なエラー情報**: ログやエラーレスポンスから問題の特定が容易に

## 制限事項

- **処理時間の増加**: リクエスト間待機とリトライ処理により、一括生成の処理時間が増加する可能性がある
  - 例: 10シーン × 500ms待機 = 最低5秒の追加時間
  - リトライ発生時はさらに増加
- **完全な成功保証ではない**: Fish Audio APIの障害や長時間のレート制限が続く場合は失敗する可能性がある

## 代替案

### 案A: バッチ処理のジョブキュー化

一括生成をバックグラウンドジョブとして実行し、進捗状況をポーリングで取得する方式。

**メリット**:
- フロントエンドのタイムアウト制限を回避
- ジョブ失敗時の再実行が容易

**デメリット**:
- 実装が複雑（ジョブキュー、進捗管理、WebSocketまたはポーリング）
- インフラ追加が必要（Redis等）

**判断**: 現時点では過剰な実装。まずは提案案（リトライ + 待機時間）を試し、それでも問題が解決しない場合に検討。

### 案B: 並列度制限付き並列処理

完全な直列ではなく、2-3リクエストまでの並列実行を許可する。

**メリット**:
- 処理時間の短縮

**デメリット**:
- Fish Audio APIのレート制限が厳しい場合、効果が薄い
- 実装が複雑

**判断**: ユーザー要求が「並列ではなく直列」なので、この案は採用しない。

## 備考

- 現在の実装は既に直列処理されているため、「並列→直列」への変更は不要
- 主な問題はレート制限対応の欠如と思われるため、リトライ処理の実装が重要
- 待機時間は必須ではないが、API負荷軽減のため推奨
