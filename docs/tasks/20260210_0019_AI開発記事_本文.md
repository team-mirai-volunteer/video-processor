# Claude Code Webを10並列で回す、超並列バイブコーディングを実現する設計とガードレールについて


チームみらい 永田町エンジニアチームの[伊藤](https://x.com/jujunjun110)です。

選挙も終わったので、最近の開発スタイルについて書いてみようと思います。

[まるみえ政治資金の記事](https://note.com/jujunjun110/n/na653d4120d7e)を書いてから約4ヶ月、AIコーディングの世界は超スピードで変化し、それに合わせ自分の開発スタイルもだいぶ変化しました。

自分にとって大きかったのは、

- Claude Code Webの登場で、並列化コストが下がったこと
- Claude Code Slash Command の登場で、作業の定型化をすることで、作業クオリティを上げやすくなったこと

でした。

これらを突き詰めていって、最近では、Claude Code Opus 4.6 を、常時3~4並列、大きい機能の実装時には10並列で回すような超並列開発が自分のスタイルになってきました。

注: タイトルの “バイブコーディング”とは、設計とガードレールを徹底したうえで、個々のコードレビューは最小限にし、AIの生成物を信頼して進めるスタイルを指しています。


今回の選挙戦では、各選挙区から大量にGoogleDriveにアップロードされてくる演説動画を、自動で文字起こしして管理し、AIに指示することで切り抜き用の短いクリップを大量に作ったり、字幕合成するような内部ツールを一週間くらいで作りました。その作り方を例にして、最近の僕の開発スタイルについて紹介してみようと思います。

（Claude Code Webの並列セッション一覧の画像）

上の画像は実際の開発風景です。左のサイドバーに「Implement task C1」「Implement task C2」...とClaude Code Webのセッションが並んでいて、**それぞれが独立したタスクを同時に実装している**状態。

### とても大事な注意事項

ここに書いてあることは**「僕はこうやったら結構うまくいったよ」くらいのもの**であり、万能な方法論ではありません。

- フルスクラッチの開発であること
- TypeScript + Next.js + Express というLLMが得意な技術スタックであること
- 1人（+AI）で開発しているため、コンフリクトや合意形成のコストが低いこと
- 大まかに動けば有用で、エッジケースにおけるバグの存在が致命的な事象にならないタイプのプロダクトであること

これらの前提があってこその話なので、一つの事例としてお読みください。

## なぜ並列で回せるのか？

10並列で実装を回すとなると、一番気になるのはファイルの衝突ですよね。

この点については、設計ルールを「ガッチガチ（自分比）」に固めることで、どこに何を実装するか自明にすることで解決しています。

### 機能分離 × レイヤーで「触るファイル」を自明にする

今回のバックエンドは、機能コンテキスト単位でディレクトリを完全に分離しています。

```
apps/backend/src/contexts/
├── clip-video/    # 動画クリップ切り出し機能
├── shorts-gen/    # ショート動画生成機能
└── shared/        # 機能間で共有するコード
```

またそれぞれの機能の中には、レイヤードアーキテクチャに沿った4つのレイヤーがあります。

```
contexts/clip-video/
├── presentation/
│   ├── routes/        # APIエンドポイント定義
│   └── middleware/    # 認証・バリデーション等
├── application/
│   ├── usecases/      # ユースケースごとの処理フロー
│   └── services/      # 複数ユースケースで共有するロジック
├── domain/
│   ├── models/        # エンティティ・値オブジェクト
│   ├── services/      # ドメイン固有のビジネスルール
│   └── gateways/      # 外部依存の抽象インターフェース
└── infrastructure/
    ├── repositories/  # DB操作の実装
    └── clients/       # 外部API・FFmpeg等の実装
```

ここまで厳格にレイヤーを深く分けるのは、人間が手で書くと「こんなシンプルな処理にもUseCase作るの？」と面倒に感じるところですが、**AIにとっては実装量は苦にならない**。

むしろ、このように設計をちゃんとすることで、各レイヤーに何を置くかが自明になります。

例えば「動画に字幕を付けられるようにする」という新機能があった場合、

- `domain/models/` → 切り抜き（Clip）や字幕（Subtitle）の値オブジェクトを定義
- `domain/gateways/` → 字幕合成処理の抽象インターフェースを定義
- `infrastructure/clients/` → FFmpegを使った字幕合成の実装
- `application/usecases/` → 「クリップに字幕を付ける」ユースケース
- `presentation/routes/` → 字幕付与APIのエンドポイント

実装場所が自明なら、タスクの並列化も自然にできます。まずPhaseAでAPIの形とgatewayのインターフェース（抽象）だけ決めてしまえば、その「契約」に基づいてフロントエンド・ドメインモデル・インフラ層をそれぞれ独立して実装できる。

- **PhaseA**: APIとgatewayのインターフェースを定義（契約を決める）
- **PhaseB1, B2, B3**: フロントエンド / ドメインモデル / インフラ層のFFmpeg実装
- **PhaseC**: プレゼンテーション・アプリケーション層を実装して統合

ここで、PhaseBの3つは触るファイルが完全に別なので、3セッション並列で同時に走らせられるわけです。


## 超並列バイブコーディングの具体的なフロー

設計による境界の話をしたところで、実際のフローを紹介します。

### Step 1: 設計ドキュメントを作る（`/plan`コマンド）

Claude Codeには`/plan`というslash commandを用意しています。実行すると、Claude Codeが以下の手順で設計ドキュメントを生成します。

1. **目的（Why）の明文化**: 「なぜこの実装が必要か」を言語化
2. **関連コード・ドキュメントの調査**: 既存の設計ガイドを読み込み
3. **設計ドキュメントの生成**: `docs/tasks/YYYYMMDD_HHMM_{作業内容}.md` に保存
4. **レビュー待ち**: 自分で実装には進まず、人間のOKを待つ

例えばこんな感じで使えます。

```
/plan
カット済みのclipに、ffmpegで字幕を合成できる機能を作成したい。
字幕は、テキストと、開始と終了のタイムスタンプを持ち、1クリップが複数のリレーションを持つ。
ひとまず文字スタイルは考慮せず、決まったフォントやサイズでレンダリングされればいい。

なるべく並列で実行可能なように実装プランを考えてください。
```

### Step 2: レビューしてOKを出す

設計ドキュメントの中身を確認して、スコープと方針に問題がなければOK。**ここが人間の仕事**です。

実装の詳細は見ません。設計ドキュメントに書いてあるのは「目的」「影響範囲」「どのレイヤーにどういうファイルを置くか」くらいで、あとはAIに任せます。

### Step 3: Claude Code Webに投げて並列実行

OKを出した設計ドキュメントを、Claude Code Webの各セッションに渡します。先ほどの字幕機能の例なら、こんな感じで3セッションを同時に立ち上げます。

```
下記手順書内の、PhaseB1を実装してください。
手順書: （URL）
並列で別のエージェントも別のタスクを作業しているので、他のタスクは着手しないでください。
```

「他のタスクは着手しないで」という一文が地味に大事で、これがないとAIが親切心で隣のタスクまで手を出して衝突することがあります。

### Step 4: PRが上がってくるのでレビュー → マージ

各セッションが実装を終えるとPRを作ってくれるので、CIが通っていることを確認してマージ。

完了した設計ドキュメントは `docs/tasks/` にアーカイブ。今回のプロジェクトでは**60件以上の設計ドキュメント**がアーカイブされていて、設計判断の履歴がそのまま残っています。

## 並列で回しても品質が崩れないガードレール

このような大雑把な回し方をすると、セッションによっては低品質なコードが上がってくるのでは？と思った方もいるかもしれません。ここは、ガードレールとなる仕組みを多重に用意することで、品質の低いコードはマージされないようにしています。

### CLAUDE.md + slash commandで、AIに読ませる情報を構造化する

CLAUDE.mdには**どんな作業でも共通で参照すべき情報**（コマンド一覧、機能構成、コーディング規約、Git hook設定）だけを記載しています。

そのうえで、**機能 × レイヤー単位のslash commandを用意**。

```
.claude/commands/
├── docs/backend-architecture-guide.md # バックエンド設計の原則
├── docs/backend-testing-guide.md # バックエンドテスト設計の原則
├── backend-clip-video.md    # clip-videoのバックエンド修正
├── backend-shorts-gen.md    # shorts-genのバックエンド修正
├── front-clip-video.md      # clip-videoのフロントエンド修正
├── front-shorts-gen.md      # shorts-genのフロントエンド修正
├── plan.md                  # 設計ドキュメント作成
├── review.md                # 設計レビュー
└── ...
```

たとえば `/backend-clip-video` を実行すると、Claude Codeが `docs/backend-architecture-guide.md` `docs/clip-video-backend-guide.md` を自動で読み込んでから実装に入ります。

CLAUDE.md（常に読む共通情報）+ slash command（タスクに応じて読む専門情報）の2層構造で、**コンテキストを消費しすぎることを防ぎながら、どのセッションにも同じルールが注入される**。これが並列で回しても実装の統一感が保たれる理由です。

### dependency-cruiserで依存方向の違反を機械的に検出する

設計ルールを決めても、守られなければ意味がない。特に並列で複数のAIが同時にコードを書いている状況では、**人間が全部目で見るのは無理**です。

そこで[dependency-cruiser](https://github.com/sverweij/dependency-cruiser)を導入しています。これはJavaScript/TypeScriptプロジェクトのimportを静的解析して、**「このモジュールはあのモジュールに依存してはいけない」といったルールへの違反を検出**してくれるツールです。CIに組み込んで、PRごとに依存関係の方向を自動で検証しています。

**バックエンド側のルール（一部）:**

- Domain層は他のどの層にも依存してはならない
- Application層はInfrastructure層に依存してはならない
- BC間の直接依存は禁止（shared経由のみ許可）

**フロントエンド側のルール（一部）:**

- UIコンポーネントはfeaturesに依存してはならない
- features間の直接依存は禁止

（dep-cruiserの設定ファイルの画像）

### テストもAIに書かせて、カバレッジを妥協しない

並列でコードを量産するなら、テストも同じ密度で書かないと品質は守れません。このプロジェクトでは、**レイヤーごとにテスト戦略を固定**しています。

- **Domain層・Application層**: ユニットテストで**原則カバレッジ100%を目指す**。ビジネスロジックの核心なので、ここのテストは絶対に手を抜かない
- **Infrastructure層**: FFmpegの動画処理やLLMクライアントなど、外部依存のあるコードにも**原則としてインテグレーションテストを書かせる**。いつでも動作確認できる状態を保つ

テスト戦略もレイヤーで決まるので、AIが「このコードにはどんなテストを書けばいいか」を迷わない。slash commandでテストガイドラインも読み込ませているので、10並列で書いても**テストの粒度と書き方が揃う**わけです。

### 3段階のガードレールで、AIの出力を自動検証する

コード品質のチェックは3段構えにしています。

1. **pre-commit**: git commit時に `lint-staged` で変更ファイルだけBiome check
2. **pre-push**: git push時に `lint && typecheck` で全体チェック
3. **CI**: Biome + Knip（デッドコード検出）+ dep-cruiser + テスト

個人的に一番効いているのが**pre-push hook**です。人間が手で開発しているときは、pushのたびにlint + typecheckが走るのは正直うざい。でもClaude Code Webの並列開発では事情が違います。

- 10セッションが個別にpushしているので、**1セッションのpushに時間がかかっても人間は気にならない**
- 逆にpre-pushで弾かなかった場合、**CIで失敗してからセッションに差し戻す**のがとても面倒。すでにセッションが終了していたり、コンテキストが流れていたりする

つまり、push前にAIが自力でエラーを直してくれるpre-push hookは、AI並列においてはとても有用に感じます。

もう一つ重要なのが、**CLAUDE.mdに `--no-verify` は原則禁止と明記している**こと。AIはGit hookで怒られると `--no-verify` でスキップしようとすることがあるのですが、それをルールとして禁止しています。

さらに、大きめの実装のときは、 `/review`コマンドで、AI自身に設計ガイドラインをセルフレビューさせることもできます。`git diff` の内容をアーキテクチャガイドラインに照合して、レイヤー違反や命名の問題を指摘してくれる。dep-cruiserが拾えない**意味的な設計違反**をカバーする層として機能しています。

## それでも起きる問題と、その対処

ここまで仕組みを整えていても、問題がゼロになるわけではありません。

### 並列セッション間の衝突はたまに起きる

「衝突はほとんど起きない」と書きましたが、**ゼロではない**です。典型的なのは、複数のタスクが共通のshared層や設定ファイルを触るケース。`package.json`への依存追加が同時に走ったり、共通の型定義を別々のセッションが修正したりすると、マージでコンフリクトが起きます。

対処としては、**依存関係のあるタスクは順番に回す**（設計ドキュメントの段階で依存関係を整理しておく）ことと、コンフリクトが起きたら**Claude Codeに解消させる**こと。実際、マージコンフリクトの解消もAIは得意です。


### レビューは「動作確認」中心でいい

「10並列のPRを1人でレビューできるのか？」という疑問への答えは、**コードを全行読むレビューはしていない**です。

ここまでガッチガチにアーキテクチャルールを決めてdep-cruiserで検証し、テストも書かせていると、**手元で動作確認してOKなら、コードの中身を逐一見なくても品質は崩れない**というのが実感です。レイヤー違反はdep-cruiserが、デッドコードはKnipが、フォーマットはBiomeが、型はTypescriptが、それぞれ機械的に見てくれている。人間は「意図どおりに動くか」に集中すればいい。
（これは、動画を大量にさばくという用途特有で、バグが致命的になるアプリケーションではそうはいかないと思います）

もちろん、設計判断に関わるPR（新しいドメインモデルやテーブルの追加、API設計の変更など）はコードをちゃんと読むときもありますが、基本は動作確認だけですませてもそれほどおかしい実装にはならない感覚があります。

## まとめ

振り返ると、やっていることはシンプルです。

1. **設計で、どこにどんな処理が書かれるかを明確にする**（機能 × レイヤー）
2. **設計ドキュメントで並列可能なタスクを定義する**（`/plan`）
3. **Claude Code Webで並列に実装させる**
4. **仕組みで品質を守る**（dep-cruiser, knip, test, Git hooks）

**設計で境界が明確だから、タスクの分割ができる。タスクが明確だから、AIに並列で任せられる。仕組みが品質を守るから、安心して任せられる**。全部つながっています。


あくまで一例ですが、Claude Code Webの並列セッションで開発を加速させてみたい方の参考になれば嬉しいです！

### 合わせておすすめ

前回の記事では、Figma MCPを使ったデザイン実装など、今回とは違う切り口でAI開発について書いています。合わせて読んでいただくと、より全体像が掴めるかと思います！

（まる見え政治資金の記事リンク）
