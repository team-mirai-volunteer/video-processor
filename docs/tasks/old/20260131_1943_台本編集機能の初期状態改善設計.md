# 台本編集機能の初期状態改善設計

## 目的

**ユーザーが台本生成画面の初期状態において、AIチャット経由でしか台本を作成できない制約があるため、それを解消し、初期状態から自分で直接台本を書けるようにする**

現在の仕様では、台本はチャットUIを通じてAIに指示して生成させる必要がある。しかし、ユーザーによっては最初から台本の内容が決まっている場合や、AIに頼らず自分で台本を作成したい場合があるため、初期状態から手動で台本を作成・編集できる機能が求められる。

---

## 現状の課題

### 現在のフロー

1. プロジェクト作成後、企画書を生成
2. 企画書をもとに、チャットUIで台本を生成（AIがツール呼び出し `save_script` で台本を保存）
3. 台本が生成された後、初めてシーン一覧が表示され、各シーンを編集可能になる

### 問題点

- **初期状態では台本が存在しないため、ユーザーは自分で台本を書くことができない**
- AIとの対話を通じてしか台本を作成できず、ユーザーが手動で台本を書き始めることができない
- 企画書は存在するが、台本は必ずAIを通して生成する必要がある

---

## 解決アプローチ

### 基本方針

台本生成ステップにおいて、以下の2つの導線を提供する：

1. **AI生成（既存機能）**: チャットUIでAIに指示して台本を生成
2. **手動作成（新機能）**: ユーザーが最初から手動でシーンを追加して台本を作成

### UI/UX変更

#### 台本ステップ初期状態（台本未作成時）

```
┌─────────────────────────────────────────────┐
│ ③ 台本                                      │
├─────────────────────────────────────────────┤
│ 台本を作成する方法を選択してください：       │
│                                             │
│ ┌─────────────┐  ┌─────────────┐           │
│ │ AI生成      │  │ 手動作成    │           │
│ │             │  │             │           │
│ │ チャットで  │  │ 自分で      │           │
│ │ AIに指示    │  │ シーンを    │           │
│ │             │  │ 追加        │           │
│ └─────────────┘  └─────────────┘           │
└─────────────────────────────────────────────┘
```

**「手動作成」を選択した場合の表示**:

```
┌─────────────────────────────────────────────┐
│ ③ 台本                                      │
├─────────────────────────────────────────────┤
│ シーン一覧（空）                            │
│ [+ シーンを追加] ボタン                     │
└─────────────────────────────────────────────┘
```

**「AI生成」を選択した場合の表示**:

```
┌─────────────────────────────────────────────┐
│ ③ 台本                                      │
├─────────────────────────────────────────────┤
│ ┌─────────────────────────────────────────┐ │
│ │ [チャットUI - SSE対話]                   │ │
│ └─────────────────────────────────────────┘ │
└─────────────────────────────────────────────┘
```

#### シーン追加フロー（手動作成時）

1. [+ シーンを追加] ボタンをクリック
2. シーン編集フォームが表示される（SceneEditor コンポーネント）
3. 必須項目（summary, visualType, voiceText/silenceDurationMs, subtitles）を入力
4. 「保存」をクリック → API経由でシーンが作成される

---

## 技術設計

### Backend API追加

#### 新規エンドポイント: 手動台本作成

```
POST /api/shorts-gen/projects/:projectId/script
```

**Request Body**:
```typescript
{
  planningId: string;
}
```

**Response**:
```typescript
{
  id: string;
  projectId: string;
  planningId: string;
  version: number;
  createdAt: string;
  updatedAt: string;
  scenes: [];
}
```

**処理内容**:
- ShortsScript レコードを作成（シーンは空の状態）
- ユーザーが後から手動でシーンを追加できる状態にする

#### 新規エンドポイント: シーン追加

```
POST /api/shorts-gen/scripts/:scriptId/scenes
```

**Request Body**:
```typescript
{
  summary: string;
  visualType: 'image_gen' | 'stock_video' | 'solid_color';
  voiceText?: string | null;
  subtitles: string[];
  silenceDurationMs?: number | null;
  stockVideoKey?: string | null;
  solidColor?: string | null;
  order: number;
}
```

**Response**:
```typescript
{
  id: string;
  scriptId: string;
  order: number;
  summary: string;
  visualType: string;
  voiceText: string | null;
  subtitles: string[];
  silenceDurationMs: number | null;
  // ... 他のフィールド
}
```

**処理内容**:
- ShortsScene レコードを作成
- order はシーンの順番を表す（0始まり）
- ドメインモデル Scene のバリデーションを通過させる

### Backend実装レイヤー構成

#### Application層

**UseCaseの追加**:

- `CreateManualScriptUseCase`: 空の台本を作成
  - Input: `{ projectId: string, planningId: string }`
  - Output: `{ scriptId: string }`

- `AddSceneUseCase`: 台本にシーンを追加
  - Input: `{ scriptId: string, sceneData: CreateSceneParams }`
  - Output: `{ scene: Scene }`

#### Presentation層

**script.routes.ts への追加**:

```typescript
// 手動台本作成
router.post('/:projectId/script', async (req, res, next) => {
  const { projectId } = req.params;
  const { planningId } = req.body;

  const result = await createManualScriptUseCase.execute({ projectId, planningId });

  res.json({
    id: result.scriptId,
    projectId,
    planningId,
    version: 1,
    scenes: [],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  });
});

// シーン追加
router.post('/scripts/:scriptId/scenes', async (req, res, next) => {
  const { scriptId } = req.params;
  const sceneData = req.body;

  const result = await addSceneUseCase.execute({ scriptId, sceneData });

  res.json(result.scene);
});
```

### Frontend実装

#### コンポーネント構成

**ScriptGenerationStep コンポーネントの拡張**:

```tsx
// 新しいステート
const [mode, setMode] = useState<'select' | 'ai' | 'manual' | null>(null);

// モード選択UI
{mode === 'select' && (
  <div className="flex gap-4">
    <Button onClick={() => setMode('ai')}>AI生成</Button>
    <Button onClick={() => setMode('manual')}>手動作成</Button>
  </div>
)}

// AI生成モード
{mode === 'ai' && (
  <ChatUI ... />
)}

// 手動作成モード
{mode === 'manual' && (
  <div>
    <Button onClick={handleCreateEmptyScript}>台本を作成</Button>
    {script && (
      <>
        <SceneList scenes={scenes} onEditScene={handleEditScene} />
        <Button onClick={handleAddScene}>+ シーンを追加</Button>
      </>
    )}
  </div>
)}
```

#### ハンドラ実装

```typescript
// 空台本作成
const handleCreateEmptyScript = async () => {
  const response = await fetch(`/api/shorts-gen/projects/${projectId}/script`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ planningId }),
  });
  const data = await response.json();
  setScript(data);
};

// シーン追加
const handleAddScene = () => {
  setEditingScene({
    id: 'new',
    scriptId: script.id,
    order: scenes.length,
    summary: '',
    visualType: 'image_gen',
    voiceText: '',
    subtitles: [],
    silenceDurationMs: null,
    // ... 他のデフォルト値
  });
};

// シーン保存（新規作成 or 更新）
const handleSaveScene = async (sceneId: string, params: UpdateSceneParams) => {
  if (sceneId === 'new') {
    // 新規作成
    const response = await fetch(`/api/shorts-gen/scripts/${script.id}/scenes`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(params),
    });
    const newScene = await response.json();
    setScenes([...scenes, newScene]);
  } else {
    // 既存更新（既存API使用）
    await onSaveScene(sceneId, params);
  }
  setEditingScene(null);
};
```

---

## データフロー

### 手動作成フロー

```
1. ユーザーが「手動作成」を選択
   ↓
2. フロントエンド: POST /api/shorts-gen/projects/:projectId/script
   ↓
3. バックエンド: CreateManualScriptUseCase.execute()
   - ShortsScript レコード作成（scenes = []）
   ↓
4. フロントエンド: 空の台本とシーン追加UIを表示
   ↓
5. ユーザーが「+ シーンを追加」をクリック
   ↓
6. フロントエンド: SceneEditor を表示
   ↓
7. ユーザーがシーン情報を入力して保存
   ↓
8. フロントエンド: POST /api/shorts-gen/scripts/:scriptId/scenes
   ↓
9. バックエンド: AddSceneUseCase.execute()
   - Scene ドメインモデルを作成
   - バリデーション実行
   - ShortsScene レコード作成
   ↓
10. フロントエンド: シーン一覧に追加したシーンを表示
```

---

## バリデーション

### Scene ドメインモデルのバリデーション

```typescript
// domain/models/scene.ts
class Scene {
  static create(params: CreateSceneParams): Result<Scene, ValidationError> {
    // summary: 必須、1文字以上
    if (!params.summary || params.summary.trim().length === 0) {
      return { success: false, error: new ValidationError('summary is required') };
    }

    // visualType: 必須、許可された値のみ
    if (!['image_gen', 'stock_video', 'solid_color'].includes(params.visualType)) {
      return { success: false, error: new ValidationError('invalid visualType') };
    }

    // voiceText と silenceDurationMs の排他チェック
    if (params.voiceText && params.silenceDurationMs !== null) {
      return {
        success: false,
        error: new ValidationError('voiceText and silenceDurationMs are mutually exclusive')
      };
    }

    // subtitles: 配列であること
    if (!Array.isArray(params.subtitles)) {
      return { success: false, error: new ValidationError('subtitles must be an array') };
    }

    return { success: true, value: new Scene(params) };
  }
}
```

---

## モード切り替えの考慮事項

### 初期状態の判定

```typescript
// 台本未作成時: mode = 'select' → モード選択UIを表示
// AI生成途中: mode = 'ai' → ChatUIを表示
// 手動作成途中: mode = 'manual' → シーン一覧 + 追加UIを表示
// 台本作成済み: mode = 既存のモード（または 'ai' / 'manual' を記憶）

const [mode, setMode] = useState<'select' | 'ai' | 'manual' | null>(() => {
  if (script) {
    // 台本が既に存在する場合
    // version 1 かつ scenes.length === 0 なら手動作成開始
    if (script.version === 1 && scenes.length === 0) {
      return 'manual';
    }
    // それ以外は AI生成後または編集中
    return 'ai';
  }
  // 台本未作成時はモード選択
  return 'select';
});
```

### 後からモードを切り替える場合

- 手動作成モードからAI生成モードへの切り替え: チャットUIを表示し、既存のシーンをコンテキストとして使用可能
- AI生成モードから手動編集: 既存機能（シーン編集）を使用

---

## セキュリティ・エラーハンドリング

### バックエンド

- `planningId` の存在チェック: Planning が存在しない場合は NotFoundError
- `scriptId` の存在チェック: Script が存在しない場合は NotFoundError
- Scene の作成時: ドメインモデルのバリデーションが失敗した場合は ValidationError

### フロントエンド

- API呼び出し失敗時のエラー表示
- 必須フィールドの未入力チェック（フォームバリデーション）
- ネットワークエラーのリトライ機能（オプション）

---

## 既存機能への影響

### 影響範囲

- **ScriptGenerationStep コンポーネント**: モード選択UIと手動作成フローの追加
- **script.routes.ts**: 新規エンドポイント追加（既存エンドポイントは変更なし）
- **Application層**: 新規UseCaseの追加（既存UseCaseは変更なし）

### 互換性

- 既存のAI生成フロー（チャットUI経由）は変更なし
- 既存のシーン編集機能は変更なし
- 既存の台本取得API（GET）は変更なし
