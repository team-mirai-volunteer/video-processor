# クリップ切り抜き終端延長対応

## 目的

ユーザーが動画クリップを切り抜いた際に、終端部分が少し切れてしまう問題を解消するため。

## 背景・課題

現在の切り抜き処理では、AIが提案した `endTimeSeconds` をそのまま使用してFFmpegで切り抜きを行っている。しかし、実際に切り抜かれた動画では終端が少し切れてしまうケースがある。

これは以下の要因が考えられる：
- FFmpegのキーフレーム処理による微小な誤差
- AIが提案するタイムスタンプがトランスクリプトの終了時刻を参照しており、発話の余韻が含まれていない

## 対応方針

切り抜き時に `endTimeSeconds` に 0.5秒 を追加して、終端に余裕を持たせる。

## 実装箇所

### 変更対象ファイル

`apps/backend/src/contexts/clip-video/application/usecases/extract-clips.usecase.ts`

### 変更内容

FFmpeg呼び出し時に `endTimeSeconds` に0.5秒を追加する。

**変更前（213-218行目付近）:**
```typescript
await this.videoProcessingGateway.extractClipFromFile(
  sourceVideoPath,
  clipOutputPath,
  clip.startTimeSeconds,
  clip.endTimeSeconds
);
```

**変更後:**
```typescript
const CLIP_END_PADDING_SECONDS = 0.5;
await this.videoProcessingGateway.extractClipFromFile(
  sourceVideoPath,
  clipOutputPath,
  clip.startTimeSeconds,
  clip.endTimeSeconds + CLIP_END_PADDING_SECONDS
);
```

### 設計判断

| 選択肢 | メリット | デメリット |
|--------|---------|-----------|
| A. FFmpegClient内で調整 | 影響範囲が限定的 | FFmpegClientが「指定より長く切り抜く」という意外な挙動をする。責務を超えている |
| **B. UseCase内で調整（採用）** | ビジネスロジックとして明示的。FFmpegClientは指定通りに動作する | なし（1行追加するだけで複雑化しない） |
| C. Clipモデル作成時に調整 | ドメインモデルで管理できる | 他の用途（表示用など）で本来の終了時刻が必要な場合に困る |

選択肢Bを採用する理由：
- FFmpegClientは「指定された通りに切り抜く」という単純な責務だけを持つべき
- パディングの追加はビジネス要件なので、UseCase層で明示的に行うのが適切
- Clipモデルには本来のタイムスタンプを保持し、切り抜き実行時のみパディングを適用することで、データの整合性を保てる

## 動画終端を超えた場合の挙動

FFmpegの `-t`（duration）オプションは、指定した時間が動画の残り時間を超えた場合、動画の終端で自動的に処理を終了する。エラーにはならず、利用可能な範囲だけが出力される。

例：動画長が60秒、endTimeSecondsが59.8秒の場合
- パディング適用後: 59.8 + 0.5 = 60.3秒まで切り抜こうとする
- 実際の出力: 動画終端の60秒で切れる（エラーなし）

## 影響範囲

- `ExtractClipsUseCase` のクリップ切り抜き処理にのみ適用される
- 既存のクリップデータ（DBに保存済みの `endTimeSeconds`）には影響しない
- ショート動画生成機能（shorts-gen）は別のUseCaseを使用しているため影響なし
- FFmpegClientは変更なし（他の用途で使う場合も指定通りの挙動を維持）

## テスト方針

- `extract-clips.usecase.test.ts` のユニットテストで、FFmpeg呼び出し時にパディングが適用されていることを確認する
- 実際の動画での動作確認（手動テスト）
