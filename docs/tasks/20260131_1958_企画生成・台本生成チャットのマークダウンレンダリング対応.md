# 企画生成・台本生成チャットのマークダウンレンダリング対応

## 目的

ショート動画生成ページ（`/shorts-gen/[projectId]`）において、企画生成・台本生成のチャット内でAIが返答したマークダウンコンテンツを適切にレンダリングできるようにする。これにより、ユーザーが生成過程でのAIメッセージを読みやすくし、企画・台本の品質確認を効率化する。

## 現状分析

### 企画表示の実装状況

企画（Planning）の表示には既に **BlockNote** というマークダウンエディタライブラリが使用されている。

- **使用ライブラリ**: `@blocknote/core`, `@blocknote/react`, `@blocknote/shadcn`（v0.46.2）
- **実装場所**:
  - `apps/webapp/src/components/features/shorts-gen/planning/planning-block-editor.tsx`: 企画編集用のBlockNoteエディタコンポーネント
  - `apps/webapp/src/components/features/shorts-gen/planning/planning-block-editor-inner.tsx`: BlockNoteの内部実装（マークダウン⇔ブロック変換）
- **機能**:
  - マークダウン文字列をBlockNoteのブロック形式に変換して表示
  - 編集後、マークダウン文字列に逆変換して保存
  - `tryParseMarkdownToBlocks()`, `blocksToMarkdownLossy()` を利用

### チャットUIの実装状況

企画生成・台本生成チャットは共通の `ChatUI` コンポーネントを使用している。

- **実装場所**:
  - `apps/webapp/src/components/features/shorts-gen/chat/chat-ui.tsx`: チャットのメインコンポーネント
  - `apps/webapp/src/components/features/shorts-gen/chat/chat-message.tsx`: 個別メッセージの表示コンポーネント
- **現状**:
  - メッセージの `content` をプレーンテキストとして表示（`whitespace-pre-wrap` で改行は反映）
  - マークダウン記法（`**太字**`, `- リスト` など）がそのまま表示され、レンダリングされない
  - `className="prose prose-sm dark:prose-invert"` が適用されているが、マークダウンパーサーが存在しないため効果なし

### バックエンドの実装状況

- 企画生成（`generate-planning.usecase.ts`）: AIが企画書をマークダウン形式で生成し、`save_planning` ツールで保存
- 台本生成（`generate-script.usecase.ts`）: AIがシーン配列をJSON形式で生成し、`save_script` ツールで保存
- **チャット応答**: どちらもストリーミングチャットで、AIの途中応答はマークダウン形式で返される可能性がある

## 課題

1. **企画生成チャット**: AIが企画書の草案やフィードバックをマークダウンで返しても、プレーンテキスト表示のため読みづらい
2. **台本生成チャット**: AIが台本案や修正案をマークダウンで返しても、プレーンテキスト表示のため読みづらい
3. **既存ライブラリの未活用**: 企画表示で使用している BlockNote が、チャット表示では活用されていない

## 設計方針

### 基本方針

- **企画表示との一貫性**: 企画で使用している BlockNote をチャットメッセージのレンダリングにも活用
- **読み取り専用モード**: チャットメッセージは編集不可のため、BlockNote を読み取り専用モードで使用
- **最小限の変更**: 既存の BlockNote 実装を最大限再利用し、新規ライブラリの導入は避ける

### 実装アプローチ

#### 案A: BlockNote を読み取り専用モードで使用（推奨）

企画表示で使用している `BlockNoteEditorInner` を参考に、読み取り専用の BlockNote ビューアーコンポーネントを作成する。

**メリット**:
- 企画表示と一貫したマークダウンレンダリング
- 既存のライブラリを再利用（新規依存なし）
- 編集機能を無効化することで、チャット専用の軽量ビューアーとして使用可能

**デメリット**:
- BlockNote はエディタ機能が中心で、読み取り専用にするための設定が必要
- SSR 非対応のため、dynamic import が必要

#### 案B: 軽量マークダウンライブラリを追加

`react-markdown` + `remark-gfm` などの軽量ライブラリを追加する。

**メリット**:
- チャットメッセージのレンダリングに最適化されている
- 読み取り専用のため、軽量で高速

**デメリット**:
- 新規依存ライブラリの追加
- 企画表示とマークダウンのレンダリング結果が異なる可能性

### 推奨案: 案A（BlockNote 読み取り専用モード）

企画表示との一貫性を重視し、既存の BlockNote を再利用する。

## 実装詳細

### 1. BlockNote 読み取り専用コンポーネントの作成

**ファイル**: `apps/webapp/src/components/features/shorts-gen/chat/markdown-viewer.tsx`

```tsx
'use client';

import type { Block } from '@blocknote/core';
import { useCreateBlockNote } from '@blocknote/react';
import { BlockNoteView } from '@blocknote/shadcn';
import { useEffect, useRef } from 'react';

interface MarkdownViewerProps {
  content: string;
}

async function parseMarkdownToBlocks(
  editor: ReturnType<typeof useCreateBlockNote>,
  markdown: string
): Promise<Block[]> {
  try {
    const blocks = await editor.tryParseMarkdownToBlocks(markdown);
    return blocks;
  } catch {
    return [
      {
        id: 'default',
        type: 'paragraph',
        props: {
          textColor: 'default',
          backgroundColor: 'default',
          textAlignment: 'left',
        },
        content: [{ type: 'text', text: markdown, styles: {} }],
        children: [],
      },
    ];
  }
}

export function MarkdownViewer({ content }: MarkdownViewerProps) {
  const editor = useCreateBlockNote({
    editable: false, // 読み取り専用
  });
  const initializedRef = useRef(false);

  useEffect(() => {
    if (!initializedRef.current && editor) {
      initializedRef.current = true;
      parseMarkdownToBlocks(editor, content).then((blocks) => {
        editor.replaceBlocks(editor.document, blocks);
      });
    }
  }, [editor, content]);

  return (
    <BlockNoteView
      editor={editor}
      theme="light"
      editable={false}
    />
  );
}
```

### 2. チャットメッセージコンポーネントの修正

**ファイル**: `apps/webapp/src/components/features/shorts-gen/chat/chat-message.tsx`

AIメッセージ（`role === 'assistant'`）の場合に、`MarkdownViewer` を使用する。

```tsx
import dynamic from 'next/dynamic';

const MarkdownViewer = dynamic(
  () => import('./markdown-viewer').then((mod) => mod.MarkdownViewer),
  { ssr: false }
);

export function ChatMessage({ message, className }: ChatMessageProps) {
  const isUser = message.role === 'user';
  const isSystem = message.role === 'system';
  const isAssistant = message.role === 'assistant';

  // ... 既存のシステムメッセージ処理 ...

  return (
    <div className={...}>
      <MessageAvatar role={message.role} />
      <div className={...}>
        <div className={...}>
          {isAssistant ? (
            <div className="prose prose-sm dark:prose-invert max-w-none">
              <MarkdownViewer content={message.content} />
              {message.isStreaming && <StreamingIndicator />}
            </div>
          ) : (
            <div className="prose prose-sm dark:prose-invert max-w-none whitespace-pre-wrap break-words">
              {message.content}
              {message.isStreaming && <StreamingIndicator />}
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
```

### 3. スタイル調整

BlockNote のスタイルが企画編集画面と同じになるため、チャットメッセージ内では以下の調整が必要な場合がある:

- フォントサイズの縮小（`prose-sm` クラスの適用）
- 背景色の調整（チャットバブル内での表示に最適化）

必要に応じて、`MarkdownViewer` にカスタムクラスを適用できるようにする。

### 4. ストリーミング対応

現在、チャットメッセージはストリーミングで段階的に表示される。MarkdownViewer は `content` が変更されるたびに再レンダリングされるため、ストリーミング中も適切に表示される。

ただし、ストリーミング中のパフォーマンスが気になる場合は、以下の最適化を検討:

- `useEffect` の依存配列に `content` を追加し、変更時のみ再パース
- デバウンス処理（ストリーミング中は頻繁な更新を抑制）

## 実装範囲

### 対象ファイル

1. **新規作成**:
   - `apps/webapp/src/components/features/shorts-gen/chat/markdown-viewer.tsx`

2. **変更**:
   - `apps/webapp/src/components/features/shorts-gen/chat/chat-message.tsx`

### 対象外

- ユーザーメッセージ（`role === 'user'`）: プレーンテキストのまま（ユーザーがマークダウンを入力することは想定していない）
- システムメッセージ（`role === 'system'`）: プレーンテキストのまま

## テスト方針

### 手動テスト

1. 企画生成チャットで、AIが企画書の草案をマークダウン形式で返すことを確認
2. 台本生成チャットで、AIが台本案をマークダウン形式で返すことを確認
3. ストリーミング中のマークダウンレンダリングが正常に動作することを確認
4. 長文マークダウンでのパフォーマンス確認

### E2Eテスト（オプション）

`apps/webapp/src/components/features/shorts-gen/chat/chat-message.test.tsx` （存在する場合）に、マークダウンレンダリングのテストを追加。

## リスク・制約

### パフォーマンス

BlockNote はエディタ機能を含むため、軽量マークダウンライブラリと比較してバンドルサイズが大きい。ただし、既に企画表示で使用しているため、追加のバンドルサイズ増加は最小限。

### ストリーミングとの相性

ストリーミング中、`content` が頻繁に更新されるため、BlockNote の再パースが頻発する可能性がある。パフォーマンス問題が発生した場合は、デバウンス処理を追加する。

### ブラウザ互換性

BlockNote は SSR 非対応のため、`dynamic import` が必須。Next.js のクライアントコンポーネントとして動作させる必要がある。

## 今後の展望（対象外）

- ユーザーメッセージのマークダウン入力対応（必要に応じて）
- マークダウンプレビュー機能の追加（チャット入力欄）
- BlockNote のカスタムブロックタイプの追加（動画埋め込みなど）

## 参考

- BlockNote 公式ドキュメント: https://www.blocknotejs.org/docs
- 既存実装: `apps/webapp/src/components/features/shorts-gen/planning/planning-block-editor-inner.tsx`
