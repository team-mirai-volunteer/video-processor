# パイプラインUIステート一貫性改善設計

## 目的

ユーザーが処理パイプラインの進行状況を正確に把握できるようにするため。

現状のUI表示が実際の処理状態と乖離しており、ユーザーが混乱する状態を解消する。

## 現状の問題点

### 問題1: 「全ステップ実行」時のステート表示が不正確

現在の `handleRunAllSteps` 関数では、処理開始時に以下のように状態を設定している：

```typescript
setSteps({
  cache: { status: 'running' },
  extractAudio: { status: 'running' },
  transcribe: { status: 'running' },
  refine: { status: 'pending' },
});
```

**問題点:**
- キャッシュ、音声抽出、文字起こしが **同時に「実行中」** と表示されるが、実際は順番に実行される
- バックエンドの `transcribeVideo` は単一のAPIコールで全処理を行い、フロントエンドは完了を待つだけ
- 処理完了後に `onStepComplete` → `pollStatus` で状態取得するまで、UIが更新されない

### 問題2: 個別ステップ完了時のUI更新タイミング

各ステップの完了処理（例: `handleCacheVideo`）は以下のフロー：

```
1. API呼び出し完了
2. ステップを 'completed' に更新
3. onStepComplete() → pollStatus() を呼び出し
```

`pollStatus` は `getVideoStatus` Server Action を呼び出すが、これはバックエンドのデータベースを参照する。
フロントエンドの `steps` state とバックエンドの `transcriptionPhase` が独立して管理されているため、状態の不整合が発生しうる。

### 問題3: ステータスの粒度不足

現状のバックエンドの `VideoStatus` は以下の6状態のみ：
- `pending`, `transcribing`, `transcribed`, `extracting`, `completed`, `failed`

`TranscriptionPhase` で詳細な進捗を管理しているが、UIの4ステップ（キャッシュ、音声抽出、文字起こし、AI校正）と直接対応していない：
- `downloading` → キャッシュ
- `extracting_audio` → 音声抽出
- `transcribing`, `saving` → 文字起こし
- `uploading` → ?（どのステップにも対応しない）
- `refining` → AI校正

## 改善方針

### 方針1: フロントエンドのステートをバックエンドの `TranscriptionPhase` と同期

UIの各ステップの状態を、バックエンドの `TranscriptionPhase` から導出する。

#### UIステップとTranscriptionPhaseのマッピング

| UIステップ | TranscriptionPhase（実行中） | 完了判定 |
|-----------|---------------------------|---------|
| キャッシュ | `downloading` | `gcsUri` が存在 |
| 音声抽出 | `extracting_audio` | phaseが `transcribing` 以降 |
| 文字起こし | `transcribing`, `saving`, `uploading` | `transcription` が存在 |
| AI校正 | `refining` | `refinedTranscription` が存在 |

#### ステータス決定ロジック（疑似コード）

```typescript
function deriveStepStatus(
  video: VideoWithRelations,
  transcription: GetTranscriptionResponse | null,
  refinedTranscription: GetRefinedTranscriptionResponse | null
): StepsState {
  const phase = video.transcriptionPhase;
  const hasGcsUri = Boolean(video.gcsUri);
  const hasTranscription = Boolean(transcription);
  const hasRefinedTranscription = Boolean(refinedTranscription);

  return {
    cache: {
      status: phase === 'downloading' ? 'running'
            : hasGcsUri ? 'completed'
            : 'ready'
    },
    extractAudio: {
      status: phase === 'extracting_audio' ? 'running'
            : hasTranscription ? 'completed'
            : hasGcsUri ? 'ready'
            : 'pending'
    },
    transcribe: {
      status: ['transcribing', 'saving', 'uploading'].includes(phase) ? 'running'
            : hasTranscription ? 'completed'
            : 'pending'
    },
    refine: {
      status: phase === 'refining' ? 'running'
            : hasRefinedTranscription ? 'completed'
            : hasTranscription ? 'ready'
            : 'pending'
    }
  };
}
```

### 方針2: ステータス導出のタイミング

#### A. 初期表示時
- `useMemo` で props（`video`, `transcription`, `refinedTranscription`）から導出
- 現在の実装を上記ロジックに置き換え

#### B. ポーリング時
- `video.status === 'transcribing'` の間、定期的にポーリング
- `pollStatus` のレスポンスから `deriveStepStatus` で状態を再計算
- `setSteps` で反映

#### C. 個別ステップ実行時
1. **実行開始**: 該当ステップのみ `running` に更新
2. **実行完了**: `onStepComplete` → `pollStatus` → `deriveStepStatus` で全ステップを再計算

### 方針3: 「全ステップ実行」時の状態遷移

「全ステップ実行」ボタンを押した場合の状態遷移：

```
初期状態:
  cache: running
  extractAudio: pending
  transcribe: pending
  refine: pending

↓ polling で phase = 'downloading' を検知

  cache: running (progressMessage表示)
  extractAudio: pending
  transcribe: pending
  refine: pending

↓ polling で phase = 'extracting_audio' を検知

  cache: completed
  extractAudio: running
  transcribe: pending
  refine: pending

↓ polling で phase = 'transcribing' を検知

  cache: completed
  extractAudio: completed
  transcribe: running
  refine: pending

... 以下同様
```

## 実装範囲

### 変更ファイル

1. **`apps/webapp/src/components/features/processing-pipeline/processing-pipeline.tsx`**
   - `initialSteps` の `useMemo` ロジックを `deriveStepStatus` 関数に置き換え
   - ポーリング時に `deriveStepStatus` で状態を再計算
   - `handleRunAllSteps` の初期状態設定を修正

2. **`apps/webapp/src/app/videos/[id]/video-detail-client.tsx`**
   - `shouldPoll` の条件を見直し（`transcribing` 時に常にポーリングするよう確認）

### 変更不要

- バックエンドの `TranscriptionPhase` 型は既に十分な粒度がある
- `pipeline-step.tsx` のUI表示ロジックは変更不要

## ステップ状態の決定ルール（まとめ）

| 条件 | cache | extractAudio | transcribe | refine |
|-----|-------|--------------|------------|--------|
| phase = downloading | running | pending | pending | pending |
| phase = extracting_audio | completed | running | pending | pending |
| phase = transcribing/saving/uploading | completed | completed | running | pending |
| phase = refining | completed | completed | completed | running |
| phase = null & 完了データあり | completed | completed | completed | completed |
| phase = null & 完了データなし | ready/完了状態 | ready/pending | pending | pending |

※「完了データ」= gcsUri, transcription, refinedTranscription の有無で判定
